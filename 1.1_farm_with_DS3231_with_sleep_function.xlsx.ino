//Author: Iman Chow
//Date : 2/5/2020
//Purpose: 
//1.0 Change to DS3231 RTC module 
//1.1 Add sleep function and interrupt. Update: It is decided that sleep function will not be implemented because solar controller can be programmed to totally cut off supply to the microp after a certain period of time which saves more power.


// This system use 2 pumps to distribute water to 20 plants. Some plants are young and some are matured. Water are mixed with water soluble fertilizer in a tank and pumps will be activated at certain time of the day.
// Variable AB is for young plants. The system will only spray water twice a day (dawn & dusk) 
// Variable BENDI is for matured plants where they can cope with more water & fertilizer. System will activate the pump 3 times per day (dawn, afternoon & dusk)


#include "Wire.h" 
#include "LCD.h" 
#include <Wire.h>
#include "LiquidCrystal_I2C.h" // For LCD
#include "RTClibExtended.h" //For RTC module
#include <LowPower.h> //For putting microp to sleep
LiquidCrystal_I2C lcd(0x3F,2,1,0,4,5,6,7); // declare slave address for LCD
RTC_DS3231 rtc; // declare rtc name 


char daysOfTheWeek[7][12] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}; // create array for the name of day 
Ds3231SqwPinMode modes[]= {DS3231_OFF,DS3231_SquareWave1Hz,DS3231_SquareWave1kHz,DS3231_SquareWave4kHz,DS3231_SquareWave8kHz}; //create array for the type of square wave generated by DS3213 


int AB = 5; //For young plants that need lesser amount of water & fertilizer 
int BENDI = 4; //For matured plants that can cope with more water & fertilizer
int BUTTON = 1;
int BUTTONSTATE = 0;
int LIGHTONSTATE=0;
int LIGHTON =8; //pin 2
int LIGHTOFFSTATE=0;
int LIGHTOFF =6; //pin 6
int ABcounter=0;
int ABcounter2;
int CLEARRAM=7;
int CLEARSTATE;
int wakeUpPin = 2;//external interrupt to interrupt microp up


void setup() 
{
  Wire.begin();
  Serial.begin(9600);
  delay(500);
   lcd.begin (16,2); // 16 x 2 LCD module
   lcd.setBacklightPin(3,POSITIVE); // BL, BL_POL
   lcd.setBacklight(LOW);
   lcd.home ();
   if (! rtc.begin()) 
  {
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Couldn't find RTC");
    while (1);
  }
  if (rtc.begin())
  {
    Serial.print("RTC working"); 
    Serial.println();
  }
  
  if (rtc.lostPower()) 
  {
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.println("RTC lost power, pls set the time!");
    // If the RTC have lost power it will sets the RTC to the date & time this sketch was compiled in the following line
    
    //rtc.adjust(DateTime(2020, 4, 14, 19, 24, 00));
    // This line sets the RTC with an explicit date & time, for example to set (IMPORTANT: THIS LINE NEED TO BE PROGRAMMED INTO THE RTC THE FIRST TIME ONLY)
    // January 21, 2014 at 3am you would call:
    // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
  }
   pinMode (AB,OUTPUT);
   pinMode (BENDI,OUTPUT);
   digitalWrite(AB, HIGH);
   digitalWrite(BENDI, HIGH);
   pinMode (BUTTON, INPUT);
   pinMode (LIGHTON, INPUT);
   pinMode (LIGHTOFF, INPUT);
   pinMode (CLEARRAM, INPUT);
   //pinMode(wakeUpPin, INPUT_PULLUP);
   rtc.writeSqwPinMode(Ds3231SqwPinMode::DS3231_OFF);

//  rtc.armAlarm(1, false);
//  rtc.clearAlarm(1);
//  rtc.alarmInterrupt(1, false);
//  rtc.armAlarm(2, false);
//  rtc.clearAlarm(2);
//  rtc.alarmInterrupt(2, false);
}

void loop() 
{
  
   currenttime();
   activatefert();
   activatebendi();
   buttonstate();
   backlight_onoff();
   savetoram();
   clearmem();
   //readmode();
   //setalarm1();
   //sleep1();
   //checkalarm();
}


void currenttime()//for RTC timekeeping purpose and display on a LCD
{
    byte b = i2c_eeprom_read_byte(0x57, 0);
    lcd.clear();
    lcd.setCursor(0,0);
    DateTime now = rtc.now();
    lcd.print(now.day(), DEC);
    lcd.print('/');
    lcd.print(now.month(), DEC);
    lcd.print('/');
    lcd.print(now.year(), DEC);
    lcd.print(' ');
    lcd.print(rtc.getTemp());
    lcd.println('C');
    lcd.setCursor(0,1);
    lcd.print(now.hour(), DEC);
    lcd.print(':');
    lcd.print(now.minute(), DEC);
    lcd.print(':');
    lcd.print(now.second(), DEC);
    lcd.print(' ');
    lcd.print(daysOfTheWeek[now.dayOfTheWeek()]);
    lcd.print(' ');
    lcd.print(b); 
    delay(1000);
}


void activatefert()//For younger plants 
{
  DateTime now = rtc.now();
  if (now.dayOfTheWeek()== 1,2,3,4,5,6,7)
  {
      if (now.hour()== 07)
      {
        if(now.minute()== 00)
        {
          if(now.second()==00)
          {
           digitalWrite (AB, LOW);//activate AB pump
           delay (8000); //vary this value depends on plant (10s)
           digitalWrite (AB, HIGH);//stop AB pump
           ABcounter++;
          }
        }
      }
    
       if (now.hour()== 18)
      {
        if(now.minute()== 00)
        {
          if(now.second()==00)
          {
           digitalWrite (AB, LOW);//activate AB pump
           delay (8000); //vary this value depends on plant (10s)
           digitalWrite (AB, HIGH);//stop AB pump
           ABcounter++;
          }
        }
      } 
   }
}

void activatebendi()//For matured plants
{
    DateTime now = rtc.now();
  if (now.dayOfTheWeek()== 1,2,3,4,5,6,7)
  {
      if (now.hour()== 7)
      {
        if(now.minute()== 0)
        {
          if(now.second()==00)
          {
           digitalWrite (BENDI, LOW);//activate AB pump
           delay (10000); //vary this value depends on plant (10s)
           digitalWrite (BENDI, HIGH);//stop AB pump
          }
        }
      }

      if (now.hour()== 12)
      {
        if(now.minute()== 01)
        {
          if(now.second()==00)
          {
           digitalWrite (BENDI, LOW);//activate AB pump
           delay (5000); //vary this value depends on plant (10s)
           digitalWrite (BENDI, HIGH);//stop AB pump
          }
        }
      }

      if (now.hour()== 18)
      {
        if(now.minute()== 00)
        {
          if(now.second()==00)
          {
           digitalWrite (BENDI, LOW);//activate AB pump
           delay (10000); //vary this value depends on plant (10s)
           digitalWrite (BENDI, HIGH);//stop AB pump
          }
        }
      }
      
  }
}

void buttonstate()//External button to activate AB pump 
{
    BUTTONSTATE = digitalRead(BUTTON);
    if (BUTTONSTATE==HIGH)
    {
      digitalWrite (AB, HIGH);
    }
    else
    {
       digitalWrite (AB, LOW);
       delay(1000);
       ABcounter++;
    }
}

void backlight_onoff()//Button to ON/OFF backlight for better visibility 
{
    LIGHTONSTATE =digitalRead(LIGHTON);
    LIGHTOFFSTATE = digitalRead(LIGHTOFF);
    if (LIGHTONSTATE==LOW)
      {
        lcd.setBacklight(HIGH);
      }
    

    if (LIGHTOFFSTATE==HIGH)
      {
        lcd.setBacklight(LOW);
      } 
     
}

void savetoram()//Save the time duration of when AB pump when is activated. The amount of time when AB pump activated is saved to DS3213 onbooard ROM and this variable will be display on LCD so that user can keep track whether the system is operating normally
{
    byte b = i2c_eeprom_read_byte(0x57, 0);
    Serial.print("Data in RAM:");
    Serial.print((int)b);
    Serial.println("");
    ABcounter2=b;

    if (b!=0)
    {
     ABcounter2+=ABcounter;
     i2c_eeprom_write_byte(0x57, 0,(byte *)ABcounter2);
     ABcounter=0;
    }
    else
    {
      ABcounter2=ABcounter;
     i2c_eeprom_write_byte(0x57, 0, (byte *)ABcounter2);
    }
     delay(100);
    Serial.println("");
    Serial.println("Memory written");
}

void i2c_eeprom_write_byte( int deviceaddress, unsigned int eeaddress, byte data ) //write on DS3213 ROM 
{
    int rdata = data;
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddress >> 8)); // MSB
    Wire.write((int)(eeaddress & 0xFF)); // LSB
    Wire.write(rdata);
    Wire.endTransmission();
}


byte i2c_eeprom_read_byte( int deviceaddress, unsigned int eeaddress ) //Read value on DS3213 ROM 
{
    byte rdata = 0xFF;
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddress >> 8)); // MSB
    Wire.write((int)(eeaddress & 0xFF)); // LSB
    Wire.endTransmission();
    Wire.requestFrom(deviceaddress,1);
    if (Wire.available()) rdata = Wire.read();
    return rdata;
}

// maybe let's not read more than 30 or 32 bytes at a time!
void i2c_eeprom_read_buffer( int deviceaddress, unsigned int eeaddress, byte *buffer, int length ) {
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddress >> 8)); // MSB
    Wire.write((int)(eeaddress & 0xFF)); // LSB
    Wire.endTransmission();
    Wire.requestFrom(deviceaddress,length);
    int c = 0;
    for ( c = 0; c < length; c++ )
        if (Wire.available()) buffer[c] = Wire.read();
}


void clearmem()//A button to clear the value in DS3213 ROM. Useful when user want to plant new batch of plants 
{
  CLEARSTATE = digitalRead(CLEARRAM);

  if (CLEARSTATE==LOW)
  {
    i2c_eeprom_write_byte(0x57, 0,(byte *)0);
  }
 
}

void readmode()// Read the mode which Square wave mode DS3213 is in.
{
  Ds3231SqwPinMode mode = rtc.readSqwPinMode();
  Serial.print("Sqw Pin Mode: ");
  switch(mode) {
    case DS3231_SquareWave1Hz  : Serial.println("1Hz"); break;
    case DS3231_OFF            : Serial.println("OFF"); break;
    case DS3231_SquareWave1kHz : Serial.println("1kHz"); break;
    case DS3231_SquareWave4kHz : Serial.println("4kHz"); break;
    case DS3231_SquareWave8kHz : Serial.println("8kHz"); break;
    default: Serial.println("--");
  }
}

void setalarm1()// To set DS3213 alarm so that it can produced a signal to interrupt microp
{
 rtc.setAlarm(Ds3231_ALARM_TYPES_t::ALM1_MATCH_HOURS,0,02,22);
 rtc.armAlarm(1,true);
 rtc.alarmInterrupt(1, true);
 attachInterrupt(digitalPinToInterrupt(wakeUpPin), wakeUp, FALLING);
}



void wakeUp()//Things that needs to be cleared when microp is interrupted by DS3213
{
  detachInterrupt(digitalPinToInterrupt(wakeUpPin)); 
  rtc.armAlarm(1, false);
  rtc.clearAlarm(1);
  rtc.alarmInterrupt(1, false);
}


void sleep1()//To allow microp to sleep at a certain time
{
  DateTime now = rtc.now();
   if (now.hour()== 22)
      {
        if(now.minute()== 8)
        {
          if(now.second()==00)
          {
            Serial.println("Going to sleep");
            delay(1000);
            LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF); 
            
          }
        }
      }
}

void checkalarm()// Check whether the alarm is armed
{
  if(rtc.isArmed(1))
  {
    Serial.println("Alarm 1 is armed");
  }
  else 
  {
    Serial.println("Alarm 1 is unarmed");
  }
}
